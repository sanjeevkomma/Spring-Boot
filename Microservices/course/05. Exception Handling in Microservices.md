# To Read
* The @ControllerAdvice is an annotation, to handle the exceptions globally
* The @ExceptionHandler is an annotation used to handle the specific exceptions and sending the custom responses to the client

# Handling exceptions in distributed systems in Spring Boot microservices
# 1. Global Exception Handling (Controller Advice) in each service
* Use **@ControllerAdvice or @RestControllerAdvice** to handle exceptions globally within each microservice.
* This ensures consistent error handling across the entire application
* This annotation can be applied on the Class|
* **@ExceptionHandler(value = ProductNotfoundException.class)**
* The @ExceptionHandler is an annotation used to handle the specific exceptions and sending the custom responses to the client
* This annotation can be applied on Method
# 2. Standardized / Custom  Error Responses
* Design custom error response formats that are consistent across all microservices.
* This can help with debugging when microservices communicate with each other.
# 3. Feign Client and RestTemplate Exception Handling
* When making REST calls to other microservices, use FeignClient or RestTemplate.
* You can create custom error decoders in Feign to handle exceptions coming from other services
# 4. Handling Communication Failures ( Retries, Circuit Breakers and Resilience ) 
* Communication between microservices can fail due to network issues, timeouts, or service unavailability.
* This requires proper exception handling to ensure that such failures do not cause a cascading failure
  * **Retries:** Use retry mechanisms to attempt failed requests multiple times before throwing an error.
  * **Circuit Breakers:** Implement circuit breaker patterns using libraries like Resilience4j or Hystrix to prevent repeated failures from propagating throughout the system.
  * Use circuit breaker patterns to gracefully handle failures in distributed systems.
  * With libraries like Resilience4j or Hystrix, you can automatically manage retries, timeouts, and fallback responses.
# 5. Log Correlation with Sleuth
* When multiple microservices interact, it is essential to trace the flow of requests and exceptions across services.
* Spring Cloud Sleuth and Zipkin can help with log correlation and distributed tracin
# 6. Exception Propagation with Kafka/RabbitMQ
* When services communicate via message brokers like Kafka or RabbitMQ, ensure that exceptions in one service do not break the entire message flow.
* Use dead-letter queues (DLQs) to capture failed messages for later processing.
# 7. API Gateway Exception Handling
* If you are using an API Gateway (like Spring Cloud Gateway), ensure that errors in the downstream services are handled correctly and propagated back to the client with meaningful messages.
* You can implement custom exception handling in Spring Cloud Gateway
# 8. Monitoring and Alerting
* Use tools like Prometheus, Grafana, or ELK stack (Elasticsearch, Logstash, and Kibana) to monitor microservices, track errors, and set up alerts for critical exceptions.
* Ensure you capture sufficient log information for debugging distributed failures.
# 9. Graceful Shutdown and Retry Mechanism
* Handle exceptions gracefully during shutdown or retry scenarios to ensure that pending requests or transactions are not lost.
  * Use Spring Boot's @Retryable for retrying failed operations.
  * Implement graceful shutdown mechanisms using ApplicationListener and @PreDestroy.

# Reference
* [Spring Boot - Exception Handling](https://www.tutorialspoint.com/spring_boot/spring_boot_exception_handling.htm#:~:text=The%20Controller%20Advice%20class%20to,methods%20in%20this%20class%20file.&text=The%20Product%20Service%20API%20controller,it%20throws%20the%20ProductNotFoundException%20class.)
