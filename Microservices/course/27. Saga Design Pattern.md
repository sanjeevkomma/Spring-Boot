# Definition
* The Saga design pattern is a microservices architectural pattern that helps manage distributed transactions and ensures data consistency across multiple services.
* In a distributed system, traditional transactions (like the ones handled by databases using ACID properties) are difficult to manage due to the distributed nature of services, and thatâ€™s where the Saga pattern comes in.
* It is particularly useful when each service in the system owns its own database and there is no centralized database to ensure transactional consistency.

# Key Concepts of the Saga Pattern:
1. Distributed Transaction: A Saga splits a long-running transaction into a series of smaller, manageable transactions that can be executed independently across different services.
2. Local Transactions: Each service in a Saga performs a local transaction that updates its data and triggers the next step in the process. Each local transaction should be atomic and isolated to that service.
3. Compensation (Rollback): If one step in the Saga fails, instead of rolling back the entire transaction like in a traditional database, the Saga triggers compensating transactions to undo the work done by previous steps, effectively reversing the process.

# Saga Workflow
* A Saga consists of a series of coordinated transactions where each transaction triggers the next one.
* If a transaction in the Saga fails, compensating transactions are executed to undo the changes made by previous transactions to maintain consistency.

# Types of Saga Execution
# 1. Choreography (Event-Driven):
* In this approach, there is no central coordinator. Each service publishes and listens to events from other services to drive the Saga forward.
* Each service is responsible for executing its own local transaction and then publishing an event that triggers the next service in the workflow.
* If something goes wrong, the compensating transactions are triggered via events to roll back the changes.
* **Example**
* Service A completes its transaction and publishes an event.
* Service B listens to this event, processes its own transaction, and publishes an event for Service C, and so on.
* If any service fails, it publishes a compensating event for previous services to undo their work.




















